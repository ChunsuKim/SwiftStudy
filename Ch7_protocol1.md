### 4_프로토콜은 언제 사용할까?

객체 지향에서 클래스는 객체가 가지고 있는 속성이나 메소드를 하나의 자루 안에 넣어주는 역할을 한다.
만약 이 클래스로부터 만들어진 인스턴스 객체가 어떤 기능을 실행하도록 하려면 그 객체의 메소드를 실행해야 한다.
어떤 객체의 메소드를 실행하는 것은 객체 자신이므로 실제로는 그 객체에 명령을 전달하는 것과 같다.
이렇게 다른 객체에서는 그 객체에 명령만 내릴 수 있고 하나의 객체는 그 안에서 모든 기능을 수행할 수 있도록 만든 것을 '캡슐화(Encapsulation)'라고 한다.


#### 캡슐화 이해하기

캡슐화라는 개념은 객체 지향에서 매우 중요하게 다뤄진다. 캡슐화는 캡슐이라는 막으로 싸여 있는데 캡슐을 통과할 수 있는 유일한 통로가 메소드이다.
다른 객체는 캡슐 막을 통과할 수 없으며 유일하게 메소드를 실행해 달라는 명령 또는 요청만 허용된다.

캡슐이라는 막은 성(Castle)의 성벽에 빗대어 볼 수 있다. 적을 막기 위해 만든 성은 사방이 성벽을 가로막혀 있으며 통로는 성문이 유일한 구조이다.
조선의 도읍인 한양의 성문은 동서남북 4대문이 있으니 동대문이나 남대문을 생각해 보면 쉽게 이해될 것이다.

![그림](https://user-images.githubusercontent.com/47494240/54984400-256b9c00-4ff2-11e9-833b-7f739af120b9.png)

성벽과 성문으로 만들어진 성은 함부로 들어가거나 나갈 수 없게 되어 있다. 여기에서 성은 클래스라고 하고 성벽과 성문으로 성을 둘러싸는 것을 '인터페이스(Interface)'라고 할 수 있다.
객체 지향의 일반적인 개념으로는 인터페이스라고 부르지만 스위프트에서는 '프로토콜(Protocol)'이라고 부른다.
프로토콜이란 일종의 정해진 약속을 말하는 것으로 '객체에 접근할 때는 이렇게 해야 한다.'라는 규약을 정해 놓은 것이다.

원칙적으로 클래스에 접근할 수 있는 방법은 메소드이다. 메소드는 단지 기능을 실행하는 것이기 때문에 그 클래스 안에 들어 있는 값을 클래스 밖에서 직접 건드릴 수 없도록 막아준다.
이것은 어떤 사람이 성 안에 있는 사람에게 편지를 전해야 할 때 직접 전달할 수 없고 성문을 지키는 사람에게 얘기하면 그 사람이 대신 전달해 주는 것과 같다.

성문을 지키는 사람에게 편지를 전달하는 것이 '메소드를 호출하는 것'과 같다면 성문을 지키는 사람이 성 안에 있는 집에 편지를 전달하는 과정은 '메소드의 기능이 실행되는 과정'이라고 할 수 있다.
이렇게 클래스에 접근할 때 메소드를 사용하면 함부로 클래스 안에 있는 값을 건드리지 못하게 할 수 있으므로 어떤 메소드들을 사용할 수 있는지를 프로토콜로 정의해 놓으면 편리하다.
즉, 프로토콜이라는 것을 하나 만들고 그 안에 접근할 수 있는 메소드가 무엇인지를 정하게 된다.

예를 들어, 성을 한양에 하나만 만드는 것이 아니라 평양에도 만들었다면 두 개의 성은 모양이나 그 안에 들어 있는 집의 수가 모두 달랐을 것이다.
그럼에도 불구하고 성을 만들 때는 동서남북으로 네 개의 성문을 만들어야 하고 편지를 배달할 때는 성문을 지키는 사람에게 전달해야 한다고 정해 두었다면 성에 있는 문의 개수나 성 안에 있는 사람에게 편지를 전달하는 방법은 모두 같을 것이다.

![그림](https://user-images.githubusercontent.com/47494240/54984401-256b9c00-4ff2-11e9-9485-b3184c7030f3.png)

포로토콜이 이런 내용을 미리 정해두는 것이라면 그 안에는 사용할 수 있는 메소드가 어떤 것들인지가 들어 있을 것이다.

프로토콜의 개념을 간략히 설명했으니 이제 아주 간단히 계산기 기능을 클래스로 만들어 보겠다.
계산기 기능을 만들면서 실제로 계산할 수 있는 기능을 넣을 것인데 계산기가 가질 수 있는 기능을 프로토콜로 미리 정해 두도록 할 것이다.

![그림](https://user-images.githubusercontent.com/47494240/54984402-26043280-4ff2-11e9-8a80-ddd8d03835fc.png)

계산기는 일반 계산기나 공학용 계산기 등 여러 가지 형태로 만들 수 있다. 일반 계산기도 기능에 따라 여러 가지가 있다.
하지만 계산기의 가장 기본적인 기능인 더하기, 빼기, 나누기, 곱하기를 계산기가 가져야 할 가장 기본적인 기능이라고 정한다면 이 기능을 프로토콜로 정의할 수 있다.


#### 프로토콜 사용하기
```swift
class MyCalculator {
    func add(first a: Int, second b: Int) -> Int {
        return a + b
    }
}
```
이 클래스 안에 계산기 기능을 넣는다면 가장 간단하게 만들 수 있는 것이 더하기 메소드이다. 이번에는 더하기 기능이 들어 있는 프로토콜을 정의해 보겠다.
```swift
protocol Calculator {
    func add(first a: Int, second b: Int) -> Int
}
```
프로토콜은 protocol 키워드와 함께 그 뒤에 프로토콜의 이름을 입력해서 만든다.
```swift
protocol 프로토콜이름 { ... }
```
프로토콜 안에는 기본적으로 메소드를 선언할 수 있지만 단순히 선언만 할 것이므로 중괄호나 중괄호 안에 들어가는 코드는 만들지 않는다.
함수 상자로 생각하면 함수 상자에 들어가는 값과 나오는 값이 몇 개가 있고 자료형이 무엇인지는 알지만 그 안에서 동작하는 기능은 들어 있지 않은 껍데기라는 뜻이 된다.
이렇게 만든 프로토콜은 클래스를 정의할 때 사용할 수 있다. MyCalculator1 클래스를 만들고 다음과 같이 입력합니다.
```swift
class MyCalculator1 : Calculator {
    func add(first a: Int, second b: Int) -> Int {
        return a + b
    }
}
```
어떤 클래스를 정의하면서 그 뒤에 콜론(:)을 붙이고 프로토콜 이름을 붙이면 '그 뒤에 나오는 프로토콜을 구현한다.'는 의미가 된다.
```swift
클래스이름 : 프로토콜이름
```
이 형식은 하나의 클래스가 다른 클래스를 상속 받을 때의 형식과 동일하다. 하나의 클래스는 여러 개의 프로토콜을 구현할 수 있는데 이때는 콤마(,)를 붙여주면서 여러 개의 프로토콜 이름을 넣어주면 된다.
```swift
클래스이름 : 프로토콜이름1, 프로토콜이름2, 프로토콜이름3, ...
```
그렇다면 클래스를 만들 때 그 클래스가 상속도 하면서 프로토콜 구현도 하는 경우에는 어떻게 해야 할까?
상속은 하나의 클래스만 가능하므로 상속할 클래스를 가장 먼저 넣어주고 그 뒤에 프로토콜을 입력하면 된다.
```swift
클래스이름 : 부모클래스이름, 포로토콜이름1, 프로토콜이름2, 프로토콜이름3, ...
```
프로토콜 안에는 add라는 메소드가 정의되어 있으므로 MyCalculator1 클래스에서 add 메소드의 기능을 구현해야 한다.
이렇게 만든 MyCalculator1 클래스를 사용해 인스턴스 객체를 만든 후 Calculator라는 자료형을 가진 변수에 할당하도록 한다.
```swift
var calculator : Calculator = MyCalculator1()
var result = calculator.add(first: 10, second: 10)
print("add 결과 -> \(result)")

add 결과 -> 20
```
실제로 만들어진 인스턴스 객체는 MyCalculator1 자료형이지만 이 객체는 Calculator 자료형으로된 변수나 상수에도 할당될 수 있다.
다만 이렇게 하면 Calculator 프로토콜에서 선언한 메소드만 호출할 수 있다. 코드를 실행하면 위의 출력값 같이 정상적으로 실행되는 것을 확인할 수 있다.

클래스가 자료형으로 사용될 수 있는 것처럼 프로토콜도 자료형으로 사용될 수 있다.
또한 어떤 클래스가 프로토콜을 준수한다고 하면 그 클래스를 사용해 만든 실제 객체는 그 프로토콜을 자료형으로 가질 수 있다.
이렇게 하면 계산기를 사용하고 싶을 때 계산기에 구현된 실제 기능을 일일이 클래스에서 찾지 않고 프로토콜만 보면 된다.
프로토콜에는 기능을 구현하는 코드가 들어 있지 않으니 어떤 메소드들이 정의되어 있는지 훨씬 간단하게 확인할 수 있다.

![그림](https://user-images.githubusercontent.com/47494240/54984403-26043280-4ff2-11e9-8a6c-dc5bc9b1532b.png)

프로토콜이 갖는 기능이 무엇인지 어느 정도 이해되더라도 아직 코드에서는 큰 차이를 못 느낄 수 있다. 그렇다면 새로운 계산기를 하나 더 만들어 보겠다.
친구가 만든 계산기라는 뜻으로 FriendCalculator 클래스를 하나 만든 후 Calculator 프로토콜을 구현하도록 한다.
FriendCalculator 클래스가 Calculator 프로토콜을 구현하도록 해야 하니 콜론(:) 뒤에 프로토콜의 이름을 입력한다.
이 클래스의 add 메소드 안에서는 더하기 연산이 실행되기 전에 간단한 메시지를 하나 출력하도록 한다.
```swift
class FriendCalculator : Calculator {
    func add(first a: Int, second b: Int) -> Int {
        print("FriendCalculator에서 더하기 실행 : \(a), \(b)")
        return a + b
    }
}
```
FriendCalculator 계산기의 add 메소드를 구현하는 코드는 이전에 만들었던 계산기의 add 기능과 약간 다르다. 그러나 이 메소드를 호출하는 방식은 같다. 다음 코드를 추가로 입력한다.
```swift
var calculator2 : Calculator = FriendCalculator()
var result2 = calculator2.add(first: 10, second: 10)
print("FriendCalculator에서 add 결과 -> \(result2)")

출력값) FriendCalculator에서 더하기 실행 : 10, 10
      FriendCalculator에서 add 결과 -> 20
```
FriendCalculator 클래스를 사용해서 만든 인스턴스 객체를 Calculator 자료형의 변수에 할당했으므로 똑같이 add 메소드를 호출하지만 실제로 실행되는 기능은 다르다.
코드를 실행하면 출력되는 메시지가 조금 다른 것을 확인할 수 있다.

실제 코드를 구현하는 것은 클래스가 해야 하는 일이지만 프로토콜을 통해서만 메소드를 호출할 수 있다.
따라서 그 클래스의 인스턴스 객체를 만들어 사용하더라도 인터페이스에 정의된 메소드만 알면 충분히 사용할 수 있다는 것을 이해했을 것이다.
프로토콜은 구조체에도 사용할 수 있다. 하나의 구조체를 만들고 하나 또는 여러 개의 프로토콜을 준수하도록 직접 만들어보기 바란다.


[Ch7_protocol2.md 파일로 가기](https://github.com/ChunsuKim/SwiftStudy/blob/master/Ch7_protocol2.md)

[Swift Study Contents로 돌아가기](https://github.com/ChunsuKim/SwiftStudy)

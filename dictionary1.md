### 4_딕셔너리에 들어 있는 값 빨리 찾기

딕셔너리(Dictionary)는 키-값(Key-Value) 방식으로 여러 개의 데이터를 넣어둘 수 있다. 딕셔너리 안에 들어가는 키는 그 안에 들어 있는 다른 키들과 구별되는 유일한 값이어야 한다.
이 딕셔너리는 자바와 같은 다른 언어에서 사용하는 '해시테이블(Hashtable)'과 비슷하다.

**키-값(Key-Value) 방식과 해시테이블(Hashtable)이란?**
```swift
키-값 방식은 어떤 값에 라벨을 붙여둔 것이라고 생각하면 쉽다. 
책상 위에 물건을 여러 개 놔두었을 때 비슷한 모양이면 빨리 찾기 어렵다.
이때 포스트잇을 붙여두면 그 포스트잇에 쓰인 이름만으로도 쉽게 구별할 수 있다. 
키-값 방식은 여러 개의 값이 들어 있을 때 각각의 값에 이름을 붙이는 방식이다.
이것은 다른 언어에서 보통 '해시테이블'이라고 부른다.
```
딕셔너리는 키(Key)와 값(Value)을 가져야 하므로 선언할 때도 키와 값의 자료형을 명시해야 한다. 아무런 원소도 들어 있지 않은 빈 딕셔너리 객체를 만들 때는 다음과 같은 코드를 사용한다.
```swift
var emptyDic = [Int:Int]()
```
딕셔너리를 만들 때는 배열을 만들 때처럼 대괄호를 사용하며, 그 안에 들어가는 원소는 키 다음에 콜론(:)을 붙이고 그 뒤에 값을 넣어주는 형식을 사용한다.
따라서 선언할 때도 키의 자료형 다음에 콜론(:)을 붙이고 그 다음에 다시 값의 자료형을 붙여준다.

만약 값을 숫자로 구분하고 싶다면 다음과 같은 방식으로 만들 수 있다.
```swift
var dic = [1:"소녀시대", 2:"걸스데이", 3:"티아라"]
var dic2 = [Int:String] = [1:"소녀시대", 2:"걸스데이", 3:"티아라"]
var dic3 = Dictionary<Int,String> = [1:"소녀시대", 2:"걸스데이", 3:"티아라"]
var dic4 = Dictionary<Int,String> = Dictionary<Int,String>([1:"소녀시대", 2:"걸스데이", 3:"티아라"])
```
앞에서 살펴본 코드들은 모두 똑같은 원소를 갖고 있지만 사용 방법이 약간씩 다르다. 이미 배열을 알아보았는데 딕셔너리 안에 들어 있는 원소에 접근하는 방법은 배열에 접근하는 방법과 비슷하므로 쉽게 이해할 수 있을 것이다.
예를 들어, 딕셔너리 안에 들어 있는 원소의 개수를 알고 싶다면 다음과 같이 count 속성을 사용한다.
```swift
딕셔너리객체.count
```
그리고 그 안에 들어 있는 원소에 접근하거나 수정하고 싶다면 딕셔너리 이름 뒤에 대괄호를 붙이고 대괄호 안에 키 값을 넣어준다. 여기서 대괄호 안에 들어가는 값은 해당 원소의 이름에 해당하는 키(Key)라는 것에 주의하자.
이것은 배열에서 인덱스 값을 넣어주었던 것과 다르다.
```swift
딕셔너리객체[키]
```

#### 딕셔너리 만들기

먼저 딕셔너리 객체를 하나 만들고 그 안에 들어 있는 원소를 확인하는 코드를 만들어 보겠다.
```swift
var girls : [Int:String] = [1:"소녀시대", 2:"걸스데이", 3:"티아라"]
print("girls 딕셔너리의 원소 개수 : \(girls.count)")

if (girls[1] != nil) {
    print("girls 딕셔너리의 키 1의 값 : \(girls[1]!)")
}

출력값) girls 딕셔너리의 원소 개수 : 3
출력값) girls 딕셔너리의 키 1의 값 : 소녀시대
```
girls라는 이름의 변수는 딕셔너리 자료형으로 만들어졌는데 키(Key)는 정수, 값(Value)은 문자열을 넣을 수 있도록 선언되었다.
이렇게 변수를 선언하면서 할당하도록 한 딕셔너리 객체는 대괄호를 사용해서 만들고 그 안에 콜론(:)과 콤마(,)로 구분된 원소들이 들어간다.
즉, 하나의 원소를 쓸 때는 키와 값이 콜론으로 구별되고 각각의 원소는 콤마로 구별된다.

딕셔너리 안에 들어 있는 원소의 개수는 배열과 마찬가지로 count 속성으로 확인할 수 있다. 그리고 각각의 원소를 확인하고 싶다면 딕셔너리로 선언된 변수 이름 뒤에 대괄호를 붙이고 대괄호 안에 키 값을 넣으면 된다.
대괄호 안에 넣은 키가 딕셔너리 안에 없을 때는 nil이 반환될 수 있다. 따라서 girls[1]과 같은 코드를 사용해 반환되는 값을 확인해 보면 옵셔널 자료형으로 반환되는 것을 확인할 수 있다.
여기서는 키가 1인 원소를 확인할 때 if 문의 조건 안에서 nil 값이 아닌지를 먼저 확인한 후 중괄호 안에서 girls[1]의 값을 출력할 때 느낌표(!)를 붙여 옵셔널을 강제로 해제한다.

코드를 실행하면 딕셔너리에 들어 있는 원소의 개수와 키가 1인 원소의 값을 보여준다.

앞에서 살펴보았던 배열과 다른 점은 원소가 하나의 값이 아니라 두 개의 값, 즉 키(Key)와 값(Value)으로 구성된다는 것이다.
따라서 코드를 입력하거나 코드를 해석할 때는 항상 키와 값이 쌍으로 다루어진다는 것을 이해해야 하며, 배열의 경우에는 키가 없으므로 인덱스로 원소에 접근한다는 것도 기억해야 한다.

딕셔너리 객체를 만들었으니 그 안에 들어 있는 원소를 바꾸거나 새로운 원소를 추가하는 방법, 그리고 모든 원소를 출력해 보는 방법도 알아보겠다. 다음 코드를 추가한다.
```swift
girls[1] = "여자친구"
girls[7] = "애프터스쿨"

for (key, value) in girls {
    print("걸그룹 키와 값 -> \(key) : \(value)")
}

for (key, value) in girls.sorted(by: {$0.0 < $1.0}) {
    print("걸그룹 키와 값 -> \(key) : \(value)")
}

출력값) 걸그룹 키와 값 -> 3 : 티아라
출력값) 걸그룹 키와 값 -> 2 : 걸스데이
출력값) 걸그룹 키와 값 -> 1 : 여자친구
출력값) 걸그룹 키와 값 -> 7 : 애프터스쿨
출력값) 걸그룹 키와 값 -> 1 : 여자친구
출력값) 걸그룹 키와 값 -> 2 : 걸스데이
출력값) 걸그룹 키와 값 -> 3 : 티아라
출력값) 걸그룹 키와 값 -> 7 : 애프터스쿨
```
새로 추가한 코드의 첫 번째 줄에서는 키가 1인 원소의 값을 '여자친구'로 바꾼다. 그리고 두 번째 줄에서는 키가 7인 새로운 원소를 추가한다.
배열에서 새로운 원소를 추가할 때 append라는 메소드를 사용했다는 걸 기억 할 것이다. 그런데 딕셔너리에는 이 메소드를 사용할 수 없다.
왜냐하면 딕셔너리에서는 모든 원소가 고유한 키로 구분되기 때문이다. 즉, 새로운 원소를 추가할 때도 대괄호 안에 키를 넣어주면서 값을 할당해야 한다.

딕셔너리 안에 있는 모든 원소를 확인할 때 자주 사용하는 구문은 for ~ in 이다. for 뒤에 있는 소괄호 안에는 각 원소의 키와 값이 쌍으로 넘어온다.
여기에서 키와 값은 소괄호로 감싼 하나의 투플이 된다. 그리고 딕셔너리에 들어 있는 각각의 원소가 확인될 때마다 중괄호 안의 코드가 반복 실행된다.
그런데 출력된 결과를 보면 키가 숫자로 되어 있는데도 7, 2, 3, 1과 같이 순서가 제멋대로이다. 딕셔너리는 해시테이블의 성격을 갖고 있기 때문에 키로만 구분될 뿐 정렬되지는 않는다.
만약 정렬된 결과를 출력하고 싶다면 sort 메소드를 호출하면 된다. sort 메소드로 넘겨주는 파라미터에는 클로저를 전달하며 그 안에 $ 표시가 들어간 코드를 입력한다.
클로저는 다음 장에서 자세히 살펴보겠다. 

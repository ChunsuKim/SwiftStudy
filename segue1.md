 # 세그웨이를 이용한 화면 전환
 
 세그웨이(Segue)라고 불리는 객체는 스토리보드에서 뷰 컨트롤러 사이의 연결 관계 및 화면 전환을 관리하는 역할을 합니다. 세그웨이는 화면과 화면을 연결하기 위해 아무런 소스 코드도 필요로 하지 않는다는 특징이 있는데, 뷰 컨트롤러와 뷰 컨트롤러 또는 화면 전환의 매게체가 되는 버튼과 뷰 컨트롤러 사이를 직접 연결하는 식으로 화면 전환 관계를 구성합니다.
 
 
 스토리보드상에서 세그웨이는 뷰 컨트롤러 사이에 연결된 화살표로 표시됩니다. 이 화살표는 한쪽 방향으로 향하는 모습을 하고 있는데, 이는 출발지와 목적지가 있다는 뜻입니다. 출발지와 목적지, 그 양쪽을 연결하는 일종의 다리 같은 것입니다. 세그웨이는 한쪽으로만 통행할 수 있으니 일방통행 다리(One-Way Bridge)라고 해야 정확합니다. 다시 말해 한쪽 방향으로만 흐르는 화면 전환입니다.
 
 
 소스 코드를 이용해서 화면 전환을 처리하려면 대상이 되는 뷰 컨트롤러의 정보를 읽어와 직접 인스턴스화한 후에 화면을 전환해야 하지만, 세그웨이를 이용하면 뷰 컨트롤러에 대한 정보가 없어도 됩니다. 또한 뷰 컨트롤러의 객체를 생성할 필요도 없습니다. 세그웨이가 스토리보드상의 연결 정보를 이용하여 대상 뷰 컨트롤러의 인스턴스를 자동으로 만들어주기 때문입니다. 세그웨이가 실행되는 순간 스토리보드를 통하여 이미 세그웨이의 출발지와 목적지 뷰 컨트롤러에 대한 인스턴스가 생성되고, 그 포인트가 세그웨이 객체에 설정됩니다. 따라서 해야 할 일은 단지 화면 전환을 위해 필요한 세그웨이를 찾아 실행하는 것뿐입니다.
 
 
 세그웨이의 목적지는 당연히 뷰 컨트롤러이지만, 출발점은 뷰 컨트롤러 자체가 될 수도 있고 버튼이나 테이블 셀 등의 컨트롤이 될 수도 있습니다. 이들 컨트롤은 사용자의 이벤트를 전달받아 화면 전환의 매개체 역할을 한다는 공통점을 가집니다. 출발점이 뷰 컨트롤러 자체인 경우를 **매뉴얼 세그웨이(Manual Segue)**, 버튼 등이 출발점인 경우를 **액션 세그웨이(Action Segue)** 또는 **트리거 세그웨이(Trigger Segue)** 라고 나누어 부르기도 합니다. 그러나 이 구분은 세그웨이를 실행하는 방식에서만 차이가 있을 뿐, 두 가지 방식 모두 세그웨이를 실행하기만 하면 화면 전환이 이루어진다는 점에서 공통입니다.
 
 
 메뉴얼 세그웨이를 실행하려면 UIKit 프레임워크에 정의된 performSegue(withIdentifier: sender:) 메소드를 사용합니다. 소스 코드에서 적절한 시점에 이 메소드를 호출하기만 하면 세그웨이가 실행되어 화면 전환이 이루어집니다. 반면 액션 세그웨이는 버튼의 터치 이벤트가 세그웨이 실행으로 바로 연결되므로, 소스 코드를 추가하지 않아도 화면 전환 기능을 구현할 수 있습니다.
 
 ```swift
 Segue(세그웨이)
    1. Action Segue(액션 세그웨이) : 버튼, 테이블 셀의 이벤트 트리거에 자동으로 연결
    2. Manual Segue(메뉴얼 세그웨이) : performSegue(withIdentifier: sender:)
 ```
 
 ### 액션 세그웨이
 
 액션 세그웨이는 트리거(Trigger)와 세그웨이가 직접 연결된 것을 의미합니다. 트리거란 방아쇠라는 뜻의 영어 단어로, 터치 또는 클릭 이벤트를 발생시켜 세그웨이를 실행할 수 있는 요소를 말합니다. 주로 버튼이나 테이블 셀 등의 컨트롤과 손가락으로 그리는 특정 패턴을 인식하는 제스처 등이 이에 해당합니다.
 
 
 액션 세그웨이는 화면 전환을 위해 프로그래밍 코드가 일절 필요하지 않을 뿐만 아니라, 스토리보드에 구현된 객체를 트리거로 지정하기만 하면 되므로 전체적인 구성이 굉장히 단순해진다는 장점이 있습니다. 게다가, 프로그래밍 코드를 사용할 때보다 비교도 안 되게 빠른 시간 내에 화면 이동을 구현할 수도 있죠.
 
 
 ### 메뉴얼 세그웨이
 
 메뉴얼 세그웨이는 해당 이벤트만 발생하면 자동으로 실행되는 액션 세그웨이와 달리 뷰 컨트롤러와 뷰 컨트롤러 사이에 연결되는 수동 실행 세그웨이입니다. 액션 세그웨이는 트리거의 터치에 의해 실행되므로 별도의 처리 코드가 전혀 필요 없지만, 메뉴얼 세그웨이는 트리거 없이 수동으로 실행해야 하므로 소스 코드에서 세그웨이를 실행할 메소드를 호출해야 합니다. 메뉴얼 세그웨이를 실행하기 위한 메소드는 다음과 같습니다.
```swift 
 performSegue(withIdentifier : <세그웨이식별자>, sender : <세그웨이 실행 객체>)
 ```
 두 개의 인자값은 세그웨이가 여러 개일 경우를 대비한 세그웨이 식별자와 세그웨이를 실행하는 객체 정보입니다. 필요한 시점에서 세그웨이 식별자를 통해 특정 세그웨이를 지정하고 위 메소드를 호출하면, 세그웨이가 실행되면서 화면이 전환되는 구조라고 보면 됩니다.
 
 
 ### 화면 전환 효과
 
 세그웨이는 프로그래밍 방식으로 화면을 전환하는 것과 같은 결과를 가져온다고 설명했습니다.
 화면을 전환할 때 효과를 넣어보도록 하겠습니다. 뷰간에 연결된 세그웨이를 클릭한 후 어트리뷰트 인스펙터 탭상의 Transtion 항목을 찾습니다. 그 후 Default로 초기설정 되어있는 것을 맘에 드는 효과로 바꿉니다.
 
 
 ### Unwind - 화면 복귀
 
 새로운 화면으로 전환하는 것을 Wind라고 한다면, Unwind는 Wind 작업을 해제한다는 의미라고 볼 수 있습니다. 다시 말해, 새로운 화면을 해제하고 본래의 화면으로 돌아간다는 해석이 되는 셈입니다.
 
 스토리보드의 뷰 컨트롤러 상단에 나타나는 도크 바의 아이콘 중에서 세 번째 아이콘에 마우스를 올려보면, Exit라는 툴팁이 표시됩니다. 바로 이 Exit를 이용하여 현재 화면을 종료하고 이전 화면으로 되돌아가는 Unwind Segue를 구현할 수 있습니다.
 
 Exit 아이콘은 Unwind Segue를 구현할 수 있도록 지원합니다. 화면 복귀에 사용할 버튼을 만들고 이 버튼을 Exit 아이콘에 드래그하여 트리거를 생성하거나 또는 수동으로 실행되는 Unwind Segue를 만들어 호출하면 간단하게 Unwind Segue를 구현할 수 있습니다.
 
 뷰 컨트롤러 A에서 뷰 컨트롤러 B로 화면을 이동했다고 할 때, 다시 원래의 뷰 컨트롤러 A로 되돌아가기 위한 Unwind Segueway의 구현 방식은 다음과 같습니다.
 
 1. 뷰 컨트롤러 A에 UIStoryboardSegue 타입의 인자값을 받는 @IBAction 액션 메소드를 정의합니다. 이를 'Unwind Segue 메소드'라고 부릅니다. 이때 메소드를 버튼과 연결할 필요는 없습니다.
 
 2. 뷰 컨트롤러 B에 버튼을 만들고 이를 Exit 아이콘에 드래그합니다. 트리거를 생성해주는 거죠.
 
 3. 버튼이 드래그된 Exit 아이콘은 1. 에서 생성한 메소드를 인식하고, 이를 찾아 Unwind Segue로 자동 생성해 줍니다.
 
 이 과정에서 Exit 아이콘에 버튼을 연결하는 것은 뷰 컨트롤러 B이지만, Unwind Segue 메소드를 만들어야 하는 곳은 뷰 컨트롤러 A입니다. 이 점에 유의하기 바랍니다.
 
 
 ### Unwide Segue를 이용하여 한꺼번에 여러 페이지 복귀하기
 
 아이폰은 안드로이드처럼 운영체제상에서 제공하는 뒤로 가기 버튼이 없기 때문에 앱 내부에서 뒤로 가기 버튼을 직접 만들어주어야 합니다. 네비게이션 컨트롤러를 사용하지 않는 앱일 때 뒤로 가기 버튼마저 없으면 사실상 되돌아갈 방법이 없기 때문에 앱 사용성이 심각한 결함 수준에 이르기도 합니다.
 
 그런데 실제로 사용되는 앱은 우리가 만들어 본 것처럼 화면이 단 두개로 연결되는 것이 아니라 여러 페이지에 걸쳐 단계적으로 이동하는 경우가 많습니다. 여러 페이지를 단계적으로 이동한 경우 가장 첫 화면, 즉 홈으로 돌아가려면 어떻게 해야 할까요? 그리고 만약 중간에 있던 화면으로 돌아가려면 어떻게 해야 할까요?
 
 가장 단순하게는 진행해 왔던 화면 이동 과정을 역으로 전환하면서 화면마다 뒤로 가기 버튼을 계속 눌러주는 방식을 떠올려 볼 수 있습니다. 하지만 이건 참 불편한 방식입니다. 특히 사용자 경험을 중요하게 여기는 모바일 앱은 더욱 그러합니다.
 
 1. View Controller를 선택하고 Xcode 메뉴에서 Editor -> Embed In -> Navigation Controller를 차례로 클릭하여 View Controller 앞에 내비게이션 컨트롤러를 삽입합니다.
 
 2. View Controller에 Label을 추가하여 Page 1로 표시하고, 네비게이션 바위에 네비게이션 아이템을 추가하여 타이틀을 Page 1으로 동일하게 입력합니다.
 
 3. Bar Button Item을 생성하여 네비게이션 바의 오른쪽에 추가한 다음, 어트리뷰트 인스펙터 탭에서 버튼의 Style 값을 Bordered로, System Item 값을 Play로 설정합니다.
 
 4. 새로운 뷰 컨트롤러를 추가하고, 여기에 STEP 3의 버튼을 <Ctrl> + 드래그하여 액션 세그웨이를 연결합니다. 세그웨이 타입은 [Show]로 선택합니다.
 
 5. Show 타입의 세그웨이로 연결되면 새로운 뷰 컨트롤러에 내비게이션 바가 생성됩니다. 오브젝트 라이브러리에서 Navigation Item을 찾아 여기에 추가합니다.
 
 6. 추가된 네비게이션 아이템을 더블클릭하여 타이틀을 Page 2로 입력합니다. 뷰 컨트롤러에도 레이블을 추가하여 Page 2로 입력합니다.
 
 7. STEP 3부터 6까지의 과정을 반복하여 Page 3, Page 4까지의 뷰 컨트롤러를 추가하고 세그웨이로 연결합니다. Page 2의 버튼이 Page 3로, Page 3의 버튼이 Page 4로 연결되도록 세그웨이를 이어주면 됩니다. 또한 세그웨이의 타입은 모두 [Show]로 지정합니다.
 
 8. 스토리보드에서 제일 마지막에 위치한 Page 4의 네비게이션 바에 바 버튼을 추가하겠습니다. 이 버튼은 맨 첫 화면으로 돌아가는 역할을 하게 됩니다. 네비게이션 바의 오른쪽에 바 버튼을 추가하고, 타이틀을 Home으로 입력합니다.
 
 9. 되돌아갈 화면에서 이정표 역할을 할 메소드를 작성해봅시다. Page 4의 버튼을 클릭하면 첫 번째 화면으로 돌아가게 할 것이므로 우선 첫 번째 뷰 컨트롤러에 Unwind 메소드를 생성합니다.
 

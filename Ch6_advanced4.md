### 2_클로저 이해하기

이미 잘 알고 있는 것처럼 함수 안에서는 return 키워드를 사용해 함수를 반환할 수 있다. 그런데 함수 안에서 반환하는 함수를 미리 정의해 두지 않고 함수 안에서 새로 만든 후 반환하는 것도 가능할까?
만약 가능하다면 어떻게 함수를 정의할 수 있을까?


#### 중첩 함수와 실행 컨텍스트

함수 안에 상수나 변수를 정의하면 함수 안에서만 접근할 수 있다. 그런데 함수 안에서 상수와 변수를 만드는 것뿐만 아니라 함수까지 새로 정의했다면 어떻게 될까?
함수 안에 함수를 만든 것을 '중첩 함수(Nested Function)'라고 한다.
그리고 중첩 함수를 만들었을 때 안쪽에 만든 함수를 '내부 함수(Inner Function)', 바깥쪽에 만든 함수를 '외부 함수(Outer Function)'라고 한다.

함수 안에 함수를 만들었을 때는 상수나 변수를 어디에서 접근할 수 있는지가 문제이다. 이것을 명확하게 이해하려면 '실행 컨텍스트(Execution Context)'가 무엇인지 알아둘 필요가 있다.
함수는 호출할 때마다 해당 함수의 호출 정보가 스택에 차곡차곡 쌓이게 된다. 이것을 보통 '콜 스택(Call Stack)'이라고 부르는데 함수를 호출할 때마다 실행 컨텍스트가 만들어져서 쌓인다.
실행 컨텍스트는 스위프트 코드 블록이 실행되는 환경이라고 할 수 있으며, 코드가 실행될 수 있는 여러가지 정보를 담고 있다. 여기에서 코드 블록은 대부분 함수가 된다.
다시 말해 함수가 실행되면 실행 컨텍스트가 만들어지고 이 실행 컨텍스트는 스택 안에 차곡차곡 쌓이게 되며, 스택의 제일 위에 있는 실행 컨텍스트가 현재 실행되고 있는 컨텍스트가 된다.

![그림](https://user-images.githubusercontent.com/47494240/54875674-a8e88a00-4e46-11e9-908f-f3a4b6a4fb2f.png)

add 함수를 실행하는 경우, 이 함수는 전역 컨텍스트라는 것 위에 새로운 add 실행 컨텍스트를 쌓게 된다. 그리고 add 함수의 실행이 끝나면 스택에서 꺼내어 버려진다.
만약 add 함수 안에서 add2 함수를 실행한다면 add 실행 컨텍스트 위에 add2 실행 컨텍스트가 쌓이게 된다.
다음 그림은 add 함수 안에서 add2 함수를 호출할 때 각 함수의 실행 컨텍스트가 스택에 쌓였다가 없어지는 과정을 알려준다.

![그림](https://user-images.githubusercontent.com/47494240/54875675-a8e88a00-4e46-11e9-82ee-1c2e94fc0574.png)

그러면 이렇게 스택에 쌓아 두는 이유가 뭘까? 스택의 가장 위에 있는 실행 컨텍스트는 현재 실행되고 있는 함수를 위한 것이지만 함수 실행에 필요한 정보는 이전에 실행되었던 함수에서도 참조한다.
그리고 참조할 때는 가장 위쪽에 있는 것부터 순서대로 참조한다. 즉, 가장 위에 있는 실행 컨텍스트의 정보를 참조하지만 그 안에 필요한 정보가 없다면 그 아래쪽에 있는 실행 컨텍스트를 순서대로 찾아보게 된다.

실행 컨텍스트가 만들어지면 그 안에 함수를 실행할 수 있는 정보를 담고 있는 객체가 생성되는데 이것을 '변수 객체'라고 한다.
변수 객체에는 함수로 전달되는 파라미터나 사용자가 정의한 변수 및 객체들을 저장할 수 있다.

더하기 함수인 add 함수가 실행되면 실행 컨텍스트가 만들어지고 그 안에 변수 객체가 만들어지는데 변수 객체 안에는 다음과 같은 속성들이 추가된다.

![그림](https://user-images.githubusercontent.com/47494240/54875676-a8e88a00-4e46-11e9-8bf7-991720eeaf2d.png)

변수 객체 안에는 지금 만든 변수 객체와 이전에 만든 변수 객체들을 순서대로 연결한 정보가 만들어진다.
이 정보를 사용해서 함수가 실행되기 전에 만들어진 실행 컨텍스트의 변수 객체들을 참조할 수 있다.

a나 b와 같은 파라미터 그리고 함수 안에서 선언한 변수들은 변수 객체 안에 만들어진 후 값이 할당되게 된다.

지금까지 설명한 내용을 이해했다면 다음과 같이 중첩 함수를 만드는 코드를 입력한다.
```swift
func getPower(food:Int) -> Int {
    var stored = 100
    func calcPower(foodAmount:Int) -> Int {
        stored += (foodAmount * 10)
        return stored
    }
    
    let power = calcPower(foodAmount: food)
    
    return power
}
```
getPower 함수는 음식을 넣으면 지금까지 저장한 에너지를 알려주는 기능을 간단하게 만든 것이다. 음식의 양은 숫자로 전달되고 저장한 에너지의 양도 숫자로 반환된다.
일반적인 함수로 만들었다면 getPower 함수 안에 수식 계산에 필요한 코드만 넣어도 충분했겠지만 여기서는 getPower 함수 안에 다시 calcPower 함수를 만들었다.
실제로 에너지의 양을 계산하는 기능은 calcPower 함수가 가지고 있고 그 정보를 stored라는 변수에 저장한다.

구조를 살펴보면 getPower 함수 안에 calcPower 함수가 선언되었으므로 calcPower 함수는 내부 함수가 된다.
그리고 내부 함수를 선언한 후 그 함수를 호출하여 stored 변수에 값을 할당한 후 반환한다.
이 코드가 실행되었을 때 각 함수의 실행 컨텍스트와 변수 객체 안의 속성들이 어떻게 생성되는지 정리하면 다음과 같다.

![그림](https://user-images.githubusercontent.com/47494240/54875677-a8e88a00-4e46-11e9-9813-a067feb4158b.png)

조금 복잡해 보이지만 왼쪽부터 하나하나 살펴보면 이해될 것이다. getPower 함수가 실행되기 전에는 전역 객체가 있고 getPower 함수를 실행하면 getPower 함수를 위한 실행 컨텍스트가 만들어진다.
getPower 함수가 실행되었을 때의 변수 객체들을 보면 전역 객체와 getPower 변수 객체가 같이 들어 있다.
그다음 calcPower 함수를 실행하면 calcPower 함수를 위한 변수 객체에는 세 개의 변수 객체가 같이 들어 있게 된다.

이 함수를 실행하기 위해 다음 코드를 입력한다.
```swift
var result = getPower(food: 10)
print("getPower 함수 실행 결과 : \(result)")

result = getPower(food: 20)
print("getPower 함수 실행 결과 : \(result)")

출력값) getPower 함수 실행 결과 : 200
      getPower 함수 실행 결과 : 300
```
이 코드에서는 getPower 함수를 두 번 실행하면서 어떤 결과가 나오는지 확인한다. 코드를 실행하면 위의 출력값을 확인할 수 있다.
이제 함수 안에 함수를 만들어 사용할 수 있다는 것을 이해할 수 있을 것이다.


#### 일반적인 의미의 클로저

그런데 함수를 호출할 때 함수 안에서 만든 함수를 반환하는 경우가 있다. 이것은 함수가 일급 객체로 다루어지고, 일급 객체라면 함수가 값을 반환할 때 그 값이 함수일 수도 있기 때문에 가능하다.
그러면 이번에는 앞에서 만든 내부 함수를 반환해 본다. 다음과 같은 코드를 추가한다.
```swift
func getPowerFunc() -> ((Int) -> Int) {
    var stored = 100
    func calcPower(foodAmount:Int) -> Int {
        stored += (foodAmount * 10)
        return stored
    }
    return calcPower
}

var powerFunc = getPowerFunc()
var result2 = powerFunc(10)
print("반환받은 powerFunc 함수 실행 결과 : \(result2)")

result2 = powerFunc(20)
print("반환받은 powerFunc 함수 실행 결과 : \(result2)")

출력값) 반환받은 powerFunc 함수 실행 결과 : 200
      반환받은 powerFunc 함수 실행 결과 : 400
```
getPowerFunc 함수는 에너지의 양을 계산한 후 결과 값을 반환하는 것이 아니라 에너지의 양을 계산할 수 있는 calcPower 함수를 만든 후 함수를 반환한다.
따라서 에너지의 양을 계산하려면 getPowerFunc 함수를 먼저 호출하여 calcPower 함수를 반환 받은 후 calcPower 함수를 한 번 더 호출해야 한다.

이 과정을 그림으로 나타내면 다음과 같다.

![그림](https://user-images.githubusercontent.com/47494240/54875678-a9812080-4e46-11e9-951b-8ac082a65193.png)

이전에 만든 getPower 함수를 두 번 호출했을 때의 결과 값은 200과 300이었는데 새로 만든 getPowerFunc 함수를 사용해 calcPower 함수를 반환 받은 후 호출한 결과 값은 200과 400이 되었다.
왜 이런 결과가 나왔을까?

함수가 한 번 실행될 때마다 실행 컨텍스트가 생기고 그 실행 컨텍스트는 함수 실행이 끝나면 사라진다는 것을 알고 있다.
그렇다면 getPowerFunc 함수가 실행되고 나면 getPowerFunc 함수를 위한 실행 컨텍스트는 사라지고 그 함수에서 반환한 calcPower 함수만 남게 된다.
stored 변수가 getPowerFunc 함수 안에 들어있으니 stored 변수도 없어졌을 것으로 보이는데 어떻게 이런 결과가 나왔을까?

문제는 이미 getPowerFunc 함수를 위한 실행 컨텍스트가 사라졌으므로 그 안에 들어 있는 stored 변수도 사라져야 하지만 실제로는 사라지지 않았다는 데 있다.

이것은 실행 컨텍스트가 사라지더라도 그 안에 만들어지는 변수 객체는 남아있을 수 있으며 이렇게 남아있는 변수 객체를 참조할 수 있기 때문에 벌어진 일이다.
이 과정을 그림으로 표현하면 다음과 같다.

![그림](https://user-images.githubusercontent.com/47494240/54875680-a9812080-4e46-11e9-92e2-44b5eb3f59bb.png)

getPowerFunc 실행 컨텍스트는 이 함수가 실행되고 나면 사라진다. 그러나 반환된 calcPower 함수를 호출하면 이 함수가 만들어진 시점의 변수 객체들을 참조한다.
이 때문에 calcPower 함수가 실행될 때의 변수 객체들을 보면 calcPower 변수 객체, getPowerFunc 변수 객체, 전역 객체가 모두 들어 있다.

따라서 calcPower 함수가 실행되었을 때 getPowerFunc 변수 객체에 들어 있는 stored 변수를 참조할 수 있다.
calcPower 함수가 실행될 때마다 이 stored 변수의 값이 증가되므로 코드를 실행했을 때 콘솔 창에 보이는 것처럼 증가된 stored 변수의 값이 출력된다.

이것이 함수를 일급 객체로 다루면서 생기는 중요한 특징인 '클로저(Closure)'라는 개념이다. 클로저는 이미 실행되었다 사라진 외부 함수의 변수를 참조하는 함수라고 할 수 있다.
따라서 앞에 만들어 본 코드에서는 calcPower 함수가 클로저가 된다.
클로저에서 참조하는 외부 함수의 변수를 '자유 변수(Free Variable)'라고 부르는데 클로저라는 이름은 '이 함수가 자유 변수에 대해 닫혀 있다.'라는 의미로 이해할 수 있다.
즉, 자유 변수를 만들었을 때의 실행 컨텍스트가 이미 사라졌는데도 자유 변수는 남아있고 내부 함수만 이 자유 변수에 접근할 수 있으므로 내부 함수가 자유 변수를 가둬 놓았다는 의미이다.

이런 클로저가 왜 중요한 것일까? 어떤 변수를 만들고 그 변수를 클로저에 가둬 놓으면 그 변수는 계속 메모리에 남아 있지만 다른 어떤 곳에서도 접근할 수 없다.
이 때문에 특정 함수가 특정 변수를 독점적으로 사용할 수 있다. 뿐만 아니라 클로저 함수가 메모리에서 사라지지만 않는다면 특정 변수를 메모리에 계속 유지시키면서 반복적으로 사용할 수 있다.
이런 장점들을 활용해 볼 수 있는 기회가 나중에 생길 것이다.



[Ch6_advanced5.md 파일로 가기](https://github.com/ChunsuKim/SwiftStudy/blob/master/Ch6_advanced5.md)

[Swift Study Contents로 돌아가기](https://github.com/ChunsuKim/SwiftStudy)

### 6_구조체 사용하기

클래스처럼 틀을 만들어 사용할 수 있는 또 다른 방법은 '구조체(Structure)'가 있다.
구조체는 C 언어와 같은 다른 언어에서 여러 개의 값을 하나로 묶어서 갖고 있을 수 있도록 했던 갓이다. 하지만 스위프트는 클래스처럼 인스턴스 객체를 만들어내기 위한 틀로 사용할 수 있다.
따라서 클래스와 구조체는 거의 같다고 할 수 있다.

구조체를 정의할 때는 struct 키워드를 사용한다. 구조체를 만드는 형식은 다음과 같다.
```swift
struct 구조체이름 {
  구조체정의코드
}
```
그리고 구조체는 클래스와 마찬가지로 내부에 변수와 상수, 그리고 함수를 가질 수 있었다. 그러면 사각형을 표현하는 구조체 하나를 만들어 보겠다.
```swift
struct Rectangle {
    var width = 0
    var height = 0
    
    func toString() -> String {
        return "사각형 width : \(width), height :(height)"
    }
}
// 인스턴스 객체 만드는 방법
var rect1 = Rectangle()
var rect2 : Rectangle = Rectangle(width: 200, height: 200)
var desc = rect2.toString()
print("rect2 정보 -> \(desc)")

출력값) rect2 정보 -> 사각형 width : 200, height :(height)
```
width와 height 속성에는 크기를 나타내는 숫자 값이 들어가게 했고 toString 함수는 사각형의 가로와 세로 크기 정보를 문자열로 반환하도록 했다.
이 코드를 보면 구조체를 정의하는 것이 클래스와 다르지 않음을 알 수 있다.

그러면 이렇게 정의한 구조체로 새로운 인스턴스 객체를 만드는 방법을 살펴보겠다. // 인스턴스 객체 만드는 방법 주석부터 참조

구조체로부터 새로운 인스턴스 객체를 만들 때는 구조체 이름과 함께 소괄호를 붙인다. 이것은 클래스로부터 인스턴스 객체를 만드는 방법과 같다.
인스턴스 객체는 두 개 만들어졌는데 하나는 rect라는 변수, 또 다른 하나는 rect2라는 변수에 할당되었다.

그런데 rect2 변수에 할당한 인스턴스 객체를 보면 Rectangle이라는 구조체 이름 뒤의 소괄호 안에 파라미터가 두 개 들어간다. 클래스로부터 인스턴스 객체를 만들 때를 생각해 보자.
이런 코드가 문제없이 동작하려면 Rectangle 클래스 안에 init 초기화 함수가 들어 있어야 하지만 구조체안에는 init 함수가 들어 있지 않다.
그런데 이 코드를 실행하면 아무런 문제가 발생하지 않는다.

이것은 구조체가 '멤버와이즈(Memberwise) 초기화 구문'을 제공하기 때문이다.
맴버와이즈 초기화 구문이란 구조체 안에 초기화 함수를 만들지 않아도 구조체 안에 정의한 속성들의 초기 값을 설정할 수 있는 구문을 말한다.
즉, 초기화 함수가 없어도 인스턴스 객체를 만들 때 소괄호 안에 파라미터를 넣어 할당할 수 있다.

클래스는 이런 맴버와이즈 초기화 구문을 제공하지 않으며 구조체에서만 가능하다.
다시 말해, 클래스는 파라미터가 하나도 없는 초기화 함수만 기본으로 제공하므로 나머지는 여러분이 직접 init 함수를 추가해야 한다.
하지만 구조체 파라미터가 하나도 없는 초기화 함수와 함께 모든 속성들의 초기 값을 넣을 수 있는 초기화 함수를 함께 제공한다.

구조체는 값을 전달하는 방식도 클래스와 다르다. 구조체를 사용해서 인스턴스 객체를 만든 후 변수나 상수에 할당할 때는 복사하여 할당한다.
또한 함수의 파라미터로 전달할 때도 마찬가지이다. 앞에서도 설명한 것처럼, 이것을 값(Value)에 의한 전달이라고 한다.
이에 반해 클래스로부터 만들어진 인스턴스 객체는 복사되지 않고 메모리에 하나만 존재한다.
이 때문에 구조체를 '밸류 타입(Value Type)', 클래스를 '레퍼런스 타입(Reference Type)'이라고 부르기도 한다.
우리말로 하면 구조체는 값을 전달하는 자료형, 클래스는 참조를 전달하는 자료형이라고 할 수 있다.
```swift
 * 구조체 -> 값을 전달하는 자료형
 * 클래스 -> 참조를 전달하는 자료형
```
**이렇게 클래스와 구조체는 비슷하면서도 약간 다른 점이 있는데 차이점을 정리하면 다음과 같다.**
```swift
 1. 클래스의 인스턴스 객체를 변수에 할당하면 그 변수가 인스턴스 객체를 참조(Reference)한다.
    하지만 구조체의 인스턴스 객체를 변수에 할당하면 그 변수는 인스턴스 객체를 복사(Copy)한다.
 2. 구조체의 인스턴스 객체를 만들 때 맴버와이즈 초기화 구문을 사용할 수 있다.
 3. 클래스는 상속할 수 있지만 구조체는 상속할 수 없다.
 4. 클래스의 인스턴스 객체는 타입 변환(Type Casting)이 가능하다.
 5. 클래스의 인스턴스 객체는 메모리에서 없어질 때 직접 값을 해제할 수 있도록 소멸화 구문을 제공한다.
```
상속에 대해서는 다음 장에서 자세하게 살펴본다. 여기서는 간단하게 '재산을 상속한다.'는 말처럼 이미 만들어 둔 클래스의 속성들을 사용해 새로운 클래스를 정의하는 것으로 생각하면 된다.
그리고 클래스는 상속이 가능하지만 구조체는 가능하지 않다고만 알아두자.

가장 중요한 차이점인 복사와 참조의 차이는 잘 구분해야 한다.
다시 말해, 구조체를 정의하고 그 구조체로부터 만들어진 인스턴스 객체를 새로운 변수에 할당하면 복사해서 만들어지므로 완전히 다른 인스턴스 객체가 만들어진 것과 같다.
이와 달리 클래스에서 만들어진 인스턴스 객체는 새로운 변수에 할당하더라도 이미 만들어진 인스턴스 객체를 가리키기만 하므로 메모리에 하나만 존재한다.

다음 코드처럼 구조체로부터 만들어진 인스턴스 객체를 변수에 할당한 후 처음 만들었던 인스턴스 객체 안에 있는 속성 값을 바꿔보겠다.
```swift
var rect3 = rect2
rect2.width = 300
desc = rect2.toString()
print("rect2 정보 -> \(desc)")
desc = rect3.toString()
print("rect3 정보 -> \(desc)")

출력값) rect2 정보 -> 사각형 width : 300, height :(height)
출력값) rect3 정보 -> 사각형 width : 200, height :(height)
```
rect2 변수에 할당되어 있던 Rectangle 구조체의 인스턴스 객체는 rect3이라는 이름의 변수에 다시 할당되었다. 그리고 rect2 안에 있는 width 속성의 값은 200에서 300으로 변경되었다.
코드를 실행하면 위에 출력값처럼 나오는 결과를 볼 수 있다.

rect2 변수에 할당된 인스턴스 객체의 정보를 확인해 보면 width 속성의 값이 300으로 바뀌었지만 rect3 변수에 할당된 인스턴스 객체의 정보를 확인해 보면 width 속성의 값이 그대로이다.

언뜻 생각했을 때 rect2 변수와 rect3 변수가 서로 다른 것을 나타낸다면 rect2 객체의 속성을 바꿨을 때 rect3 객체의 속성이 바뀌지 않는게 옳다고 할 수도 있다.
하지만 클래스로부터 만들어진 인스턴스 객체의 경우에는 다른 결과를 만들어 낸다.

앞에서 만든 코드와 비슷한 형태로 만들되 구조체가 아닌 클래스로 인스턴스 객체를 만들어 보기 위해서 다음 코드를 입력한다.
```swift
class Point {
    var x : Float = 0.0
    var y : Float = 0.0
    init() {
    }
    init(x: Float, y:Float) {
        self.x = x
        self.y = y
    }
    func toString() -> String {
        return "점 x : \(x), y : \(y)"
    }
}

var pnt = Point()
var pnt2 : Point = Point(x: 200.0, y: 200.0)
desc = pnt2.toString()
print("pnt2 정보 -> \(desc)")

var pnt3 = pnt2
pnt2.x = 300.0
desc = pnt2.toString()
print("pnt2 정보 -> \(desc)")
desc = pnt3.toString()
print("pnt3 정보 -> \(desc)")

출력값) pnt2 정보 -> 점 x : 200.0, y : 200.0
출력값) pnt2 정보 -> 점 x : 300.0, y : 200.0
출력값) pnt3 정보 -> 점 x : 300.0, y : 200.0
```
class 키워드를 사용해 Point 클래스를 정의했으며 그 안에는 x와 y 속성이 들어 있다. 두 개의 속성과 toString 함수가 들어 있는 것은 앞에서 만들었던 Rectangle 구조체와 비슷하다.
그러나 이 클래스로부터 새로운 인스턴스 객체를 만들려면 구조체의 형식과는 달리 init 함수가 추가되어야 한다.
이 때문에 파라미터가 하나도 없는 init 함수와 x와 y 값을 파라미터로 받는 init 함수가 추가되었다.

Point 클래스를 정의했으므로 이 클래스로부터 두 개의 인스턴스 객체를 만들고 각각 pnt와 pnt2 변수에 할당한다. 그리고 pnt2 변수에 할당되었던 인스턴스 객체는 다시 pnt3 변수에 할당한다.
이때 앞에서와 같이 pnt2 변수의 x 속성 값을 300.0으로 변경했을 때 pnt3 변수의 x 속성 값은 그대로일까? 위의 출력값을 보면 pnt3 변수의 인스턴스 객체도 바뀐 것을 확인할 수 있다.

이것은 pnt3 변수가 pnt2 변수를 가리키고 있고 pnt2 변수는 메모리에 만들어진 Point 인스턴스 객체를 가리키고 있기 때문이다.
이렇게 메모리에 있는 같은 인스턴스 객체를 가리키고 있으므로 pnt2 변수를 사용해 그 객체의 속성을 변경하면 pnt3 변수를 사용해 그 객체의 속성을 확인해도 같은 값이 나오게 된다.

이렇게 클래스로부터 만들어진 인스턴스 객체는 참조 방식으로 변수가 객체를 가리키게 된다. 따라서 두 개의 인스턴스 객체를 비교할 때는 == 기호가 아닌 === 기호를 사용해야 한다.
클래스의 인스턴스 객체는 단순히 그 인스턴스 객체 안에 들어 있는 값이 같은지를 비교하는 것이 아니라 두 대상이 같은 인스턴스 객체인지도 함께 확인해야 한다.
따라서 === 기호를 사용해야 두 개의 객체가 같은 인스턴스 객체인지 알 수 있다.

다음 코드를 추가하여 새로운 인스턴스 객체를 하나 더 만든 다음 이 객체가 pnt2 변수에 할당된 객체와 같은지 확인해 보겠다.
```swift
var pnt4 : Point = Point(x: 200.0, y: 200.0)
if pnt4 === pnt2 {
    print("pnt4와 pnt2 객체는 같습니다.")
} else {
    print("pnt4와 pnt2 객체는 다릅니다.")
}

if pnt3 === pnt2 {
    print("pnt3와 pnt2 객체는 같습니다.")
} else {
    print("pnt3와 pnt2 객체는 다릅니다.")
}

출력값) pnt4와 pnt2 객체는 다릅니다.
출력값) pnt3와 pnt2 객체는 같습니다.
```
if 키워드 뒤에 pnt4 변수와 pnt2 변수가 가리키는 인스턴스 객체가 같은지 확인하는 === 연산자가 들어 있다. 만약 == 연산자를 사용하려 하면 오류가 표시된다.
if 문에서 비교한 두 개의 객체가 같을 때는 같다는 메시지를 출력하고 다를 때는 다르다는 메시지를 출력하도록 한다.
코드를 실행하면 다음과 같이 pnt4와 pnt2 변수가 가리키는 객체는 다르지만 pnt3와 pnt2 변수가 가리키는 객체는 같다는 메시지를 볼 수 있다.

지금까지 알아본 것처럼 클래스와 구조체는 상당히 비슷하지만 다른 특징들도 가지고 있다. 그렇다면 어떤 경우에 클래스를 사용하고 어떤 경우에 구조체를 사용하는 것이 좋을까?
```swift
 구조체를 사용하는 것이 좋은 경우
 1. 여러 개의 값을 하나로 묶어두고 싶을 때
 2. 새로운 틀을 정의하는데 기존 틀을 상속해서 만들 필요가 없을 때
 3. 하나로 묶어 둔 데이터를 복사해서 만드는 것이 좋을 때
```
클래스는 새로운 인스턴스 객체를 만든 후 여러 변수에 여러 번 할당해도 인스턴스 객체를 복사해서 만들지 않으므로 메모리를 좀 더 효율적으로 사용할 수 있다.
따라서 앞에서 알아본 경우가 아니라면 클래스를 사용하는 것이 좋다.

 Quiz 21

앞에서 만들었던 Dog 클래스를 구조체로 만들어 봅니다. Dog 구조체에는 name, age 속성과 함께 toString 함수가 들어가도록 합니다.
name 변수의 자료형은 옵셔널 문자열로 하고 age 변수의 자료형은 숫자로 합니다. toString이라는 이름의 함수를 만들고 '강아지 미미의 나이는 2입니다.'처럼 강아지의 이름과 나이를 출력하게 합니다.
구조체를 정의한 후에는 Dog 객체를 하나 만들고 toString 함수를 호출합니다.
```swift
struct Dog {
    var name:String?
    var age:Int = 0
    
    func toString() {
        print("강아지 \(name)의 나이는 \(age)입니다.")
    }
}

var dog1 = Dog(name: "미미", age: 2)
dog1.toString()

출력값) 강아지 Optional("미미")의 나이는 2입니다.
```


[Ch4_classes7.md 파일로 가기](https://github.com/ChunsuKim/SwiftStudy/blob/master/Ch4_classes7.md)

[Swift Study Contents로 돌아가기](https://github.com/ChunsuKim/SwiftStudy)
